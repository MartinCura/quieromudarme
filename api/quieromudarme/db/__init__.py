# AUTOGENERATED FROM:
#     'quieromudarme/db/delete_housing_search_by_url.edgeql'
#     'quieromudarme/db/get_housing_search_by_url.edgeql'
#     'quieromudarme/db/get_housing_searches.edgeql'
#     'quieromudarme/db/get_new_housing_watches_to_notify.edgeql'
#     'quieromudarme/db/get_updated_housing_watches_to_notify.edgeql'
#     'quieromudarme/db/get_users.edgeql'
#     'quieromudarme/db/insert_housing_search.edgeql'
#     'quieromudarme/db/update_notified_housing_watches.edgeql'
#     'quieromudarme/db/upsert_housing_from_search.edgeql'
#     'quieromudarme/db/upsert_user.edgeql'
#     'quieromudarme/db/upsert_watches_for_search.edgeql'
# WITH:
#     $ python3 -m edgedb.codegen --dir ./quieromudarme/db/ --file ./quieromudarme/db/__init__.py


from __future__ import annotations
import dataclasses
import datetime
import decimal
import edgedb
import enum
import typing
import uuid


Provider = str


class NoPydanticValidation:
    @classmethod
    def __get_pydantic_core_schema__(cls, _source_type, _handler):
        # Pydantic 2.x
        from pydantic_core.core_schema import any_schema

        return any_schema()

    @classmethod
    def __get_validators__(cls):
        # Pydantic 1.x
        from pydantic.dataclasses import dataclass as pydantic_dataclass

        _ = pydantic_dataclass(cls)
        cls.__pydantic_model__.__get_validators__ = lambda: []
        return []


class Currency(enum.Enum):
    ARS = "ARS"
    USD = "USD"
    EUR = "EUR"


@dataclasses.dataclass
class DeleteHousingSearchByUrlResult(NoPydanticValidation):
    id: uuid.UUID


@dataclasses.dataclass
class GetHousingSearchByUrlResult(NoPydanticValidation):
    id: uuid.UUID
    created_at: datetime.datetime


@dataclasses.dataclass
class GetHousingSearchesResult(NoPydanticValidation):
    id: uuid.UUID
    user: GetHousingSearchesResultUser
    provider: Provider
    url: str
    query_payload: str | None
    last_search_at: datetime.datetime | None
    created_at: datetime.datetime


@dataclasses.dataclass
class GetHousingSearchesResultUser(NoPydanticValidation):
    id: uuid.UUID
    tier: UserTier
    telegram_id: int
    telegram_username: str | None


@dataclasses.dataclass
class GetNewHousingWatchesToNotifyResult(NoPydanticValidation):
    id: uuid.UUID
    user: GetNewHousingWatchesToNotifyResultUser
    watches: list[GetNewHousingWatchesToNotifyResultWatchesItem]


@dataclasses.dataclass
class GetNewHousingWatchesToNotifyResultUser(NoPydanticValidation):
    id: uuid.UUID
    tier: UserTier
    telegram_id: int
    telegram_username: str | None
    created_at: datetime.datetime


@dataclasses.dataclass
class GetNewHousingWatchesToNotifyResultWatchesItem(NoPydanticValidation):
    id: uuid.UUID
    search: GetNewHousingWatchesToNotifyResultWatchesItemSearch
    housing: GetNewHousingWatchesToNotifyResultWatchesItemHousing
    current_revision: GetNewHousingWatchesToNotifyResultWatchesItemCurrentRevision


@dataclasses.dataclass
class GetNewHousingWatchesToNotifyResultWatchesItemCurrentRevision(NoPydanticValidation):
    id: uuid.UUID
    price: decimal.Decimal
    currency: Currency


@dataclasses.dataclass
class GetNewHousingWatchesToNotifyResultWatchesItemHousing(NoPydanticValidation):
    id: uuid.UUID
    provider: Provider
    post_id: str
    url: str
    post_modified_at: datetime.datetime | None
    title: str | None
    image_url: str | None
    whatsapp_phone_number: str | None
    description: str | None


@dataclasses.dataclass
class GetNewHousingWatchesToNotifyResultWatchesItemSearch(NoPydanticValidation):
    id: uuid.UUID
    url: str
    created_at: datetime.datetime


@dataclasses.dataclass
class GetUpdatedHousingWatchesToNotifyResult(NoPydanticValidation):
    id: uuid.UUID
    user: GetNewHousingWatchesToNotifyResultUser
    watches: list[GetUpdatedHousingWatchesToNotifyResultWatchesItem]


@dataclasses.dataclass
class GetUpdatedHousingWatchesToNotifyResultWatchesItem(NoPydanticValidation):
    id: uuid.UUID
    search: GetNewHousingWatchesToNotifyResultWatchesItemSearch
    housing: GetNewHousingWatchesToNotifyResultWatchesItemHousing
    old_revision: GetNewHousingWatchesToNotifyResultWatchesItemCurrentRevision
    current_revision: GetNewHousingWatchesToNotifyResultWatchesItemCurrentRevision


@dataclasses.dataclass
class GetUsersResult(NoPydanticValidation):
    id: uuid.UUID
    tier: UserTier
    telegram_id: int
    telegram_username: str | None
    num_searches: int


@dataclasses.dataclass
class InsertHousingSearchResult(NoPydanticValidation):
    id: uuid.UUID
    user: InsertHousingSearchResultUser
    provider: Provider
    url: str
    query_payload: str | None
    last_search_at: datetime.datetime | None
    created_at: datetime.datetime


@dataclasses.dataclass
class InsertHousingSearchResultUser(NoPydanticValidation):
    id: uuid.UUID
    tier: UserTier
    telegram_id: int
    telegram_username: str | None


@dataclasses.dataclass
class UpdateNotifiedHousingWatchesResult(NoPydanticValidation):
    id: uuid.UUID


@dataclasses.dataclass
class UpsertHousingFromSearchResult(NoPydanticValidation):
    id: uuid.UUID
    is_new: bool
    added_revision: bool
    price: decimal.Decimal
    currency: Currency


@dataclasses.dataclass
class UpsertUserResult(NoPydanticValidation):
    is_new: bool
    id: uuid.UUID
    tier: UserTier
    telegram_id: int
    telegram_username: str | None
    searches: list[UpsertUserResultSearchesItem]


@dataclasses.dataclass
class UpsertUserResultSearchesItem(NoPydanticValidation):
    id: uuid.UUID
    created_at: datetime.datetime
    provider: Provider
    url: str


class UserTier(enum.Enum):
    FREE = "Free"
    PREMIUM = "Premium"


class WatchRevisionsitem(typing.NamedTuple):
    hw_id: uuid.UUID
    revision_id: uuid.UUID


async def delete_housing_search_by_url(
    executor: edgedb.AsyncIOExecutor, *, user_id: uuid.UUID, provider: str, search_url: str
) -> DeleteHousingSearchByUrlResult | None:
    return await executor.query_single(
        """\
        # # Soft-delete the housing search
        # with
        #   user_id := <uuid>$user_id,
        #   provider := <str>$provider,
        #   url := <str>$search_url,

        # update HousingSearch
        # filter
        #   .user.id = user_id
        #   and .provider = provider
        #   and .url = url
        # set {
        #   deleted_at := datetime_current(),
        # };

        # Hard-delete the housing search
        with
          user_id := <uuid>$user_id,
          provider := <str>$provider,
          url := <str>$search_url,

        delete HousingSearch
        filter
          .user.id = user_id
          and .provider = provider
          and .url = url;\
        """,
        user_id=user_id,
        provider=provider,
        search_url=search_url,
    )


async def get_housing_search_by_url(
    executor: edgedb.AsyncIOExecutor, *, search_url: str, provider: str, user_id: uuid.UUID
) -> GetHousingSearchByUrlResult | None:
    return await executor.query_single(
        """\
        select HousingSearch {
          created_at
        }
        filter
          .url = <str>$search_url
          and .provider = <str>$provider
          and .user.id = <uuid>$user_id;\
        """,
        search_url=search_url,
        provider=provider,
        user_id=user_id,
    )


async def get_housing_searches(executor: edgedb.AsyncIOExecutor) -> list[GetHousingSearchesResult]:
    return await executor.query(
        """\
        select HousingSearch {
          user: {
            tier,
            telegram_id,
            telegram_username,
          },
          provider,
          url,
          query_payload,
          last_search_at,
          created_at,
        }
        order by
          # Premium before Free
          .user.tier desc;\
        """
    )


async def get_new_housing_watches_to_notify(
    executor: edgedb.AsyncIOExecutor,
) -> list[GetNewHousingWatchesToNotifyResult]:
    return await executor.query(
        """\
        with
          HW := (
            select HousingWatch
            filter .housing_revision = .housing.current
              and not .notified
          ),
          groups := (
            group HW {
              id,
              user: {
                id,
                tier,
                telegram_id,
                telegram_username,
                created_at,
              },
              search: {
                url,
                created_at,
              },
              housing := .housing_revision.housing {
                provider,
                post_id,
                url,
                post_modified_at,
                title,
                image_url,
                whatsapp_phone_number,
                description := <str>json_get(.raw, 'description'),
              },
              current_revision := .housing_revision.housing.current {
                id,
                price,
                currency,
              },
            }
            by .user
          )

        select groups {
          user := .key.user,
          watches := .elements {
            id,
            search,
            housing := (
              # TODO: these `limit 1` should be unnecessary but modelling is imperfect
              select .housing limit 1
            ),
            current_revision := (
              select .current_revision limit 1
            ),
          },
        }
        order by
          .key.user.tier desc
          then .key.user.created_at asc
        ;\
        """
    )


async def get_updated_housing_watches_to_notify(
    executor: edgedb.AsyncIOExecutor,
) -> list[GetUpdatedHousingWatchesToNotifyResult]:
    return await executor.query(
        """\
        with
          HW := (
            select HousingWatch
            filter .housing_revision != .housing.current
          ),
          groups := (
            group HW {
              id,
              user: {
                id,
                tier,
                telegram_id,
                telegram_username,
                created_at,
              },
              search: {
                url,
                created_at,
              },
              housing := .housing_revision.housing {
                provider,
                post_id,
                url,
                post_modified_at,
                title,
                image_url,
                whatsapp_phone_number,
                description := <str>json_get(.raw, 'description'),
              },
              old_revision := .housing_revision {
                id,
                price,
                currency,
              },
              current_revision := .housing_revision.housing.current {
                id,
                price,
                currency,
              },
            }
            by .user
          )

        select groups {
          user := .key.user,
          watches := .elements {
            id,
            search,
            housing := (
              # TODO: these `limit 1` should be unnecessary but modelling is imperfect
              select .housing limit 1
            ),
            old_revision,
            current_revision := (
              select .current_revision limit 1
            ),
          },
        }
        order by
          .key.user.tier desc
          then .key.user.created_at asc
        ;\
        """
    )


async def get_users(executor: edgedb.AsyncIOExecutor) -> list[GetUsersResult]:
    return await executor.query(
        """\
        select User {
          id,
          tier,
          telegram_id,
          telegram_username,
          num_searches := count(.searches),
        }\
        """
    )


async def insert_housing_search(
    executor: edgedb.AsyncIOExecutor,
    *,
    user_id: uuid.UUID,
    provider: str,
    search_url: str,
    query_payload: str | None = None,
) -> InsertHousingSearchResult:
    return await executor.query_single(
        """\
        with
          user := (select User filter .id = <uuid>$user_id),
          provider := <str>$provider,
          url := <str>$search_url,
          query_payload := <optional json>$query_payload,

          created_search := (
            insert HousingSearch {
              user := user,
              provider := provider,
              url := url,
              query_payload := query_payload,
              last_search_at := <datetime>{},
            }
          ),

        select created_search {
          id,
          user: {
            id,
            tier,
            telegram_id,
            telegram_username,
          },
          provider,
          url,
          query_payload,
          last_search_at,
          created_at,
        }\
        """,
        user_id=user_id,
        provider=provider,
        search_url=search_url,
        query_payload=query_payload,
    )


async def update_notified_housing_watches(
    executor: edgedb.AsyncIOExecutor,
    *,
    notified_at: datetime.datetime,
    watch_revisions: list[WatchRevisionsitem],
) -> list[UpdateNotifiedHousingWatchesResult]:
    return await executor.query(
        """\
        # Update each HousingWatch so it points to a certain revision and set notified_at
        with
          notified_at := <datetime>$notified_at,
          watch_revisions := <array<tuple<hw_id: uuid, revision_id: uuid>>>$watch_revisions,

        for wr in array_unpack(watch_revisions) union (
          update HousingWatch
          filter
            .id = wr.hw_id
          set {
            housing_revision := (
              select HousingRevision filter .id = wr.revision_id
            ),
            notified_at := notified_at,
          }
        )\
        """,
        notified_at=notified_at,
        watch_revisions=watch_revisions,
    )


async def upsert_housing_from_search(
    executor: edgedb.AsyncIOExecutor, *, housing_posts: str
) -> list[UpsertHousingFromSearchResult]:
    return await executor.query(
        """\
        # Upsert Housing, creating/updating HousingRevision if appropriate

        with
          input := <json>$housing_posts,

        for hp in json_array_unpack(input) union (
          with
            housing := (
              insert Housing {
                provider := <Provider>hp['provider'],
                post_id := <str>hp['post_id'],
                url := <str>hp['url'],
                post_modified_at := <datetime>hp['modified_at'],
                title := <str>hp['title'],
                image_url := <str>json_get(hp, 'main_image_url'),
                whatsapp_phone_number := <str>json_get(hp, 'whatsapp_phone_number'),
                raw := <json>hp,
                revisions := (
                  insert HousingRevision {
                    price := <decimal>hp['price'],
                    currency := <Currency>hp['price_currency'],
                  }
                ),
              }
              unless conflict on (.provider, .post_id)
              else (
                update Housing
                set {
                  url := <str>hp['url'],
                  post_modified_at := <datetime>hp['modified_at'],
                  title := <str>hp['title'],
                  image_url := <str>json_get(hp, 'main_image_url'),
                  whatsapp_phone_number := <str>json_get(hp, 'whatsapp_phone_number'),
                  raw := <json>hp,
                  revisions += (
                    with
                      # Revision is only added if price has changed significantly
                      add_revision := (
                        (<decimal>hp['price'] > 0 and <decimal>hp['price'] <= ((1 - PRICE_OFF_PCT_THRESHOLD) * .current.price))
                        or (<decimal>hp['price'] = 0 and .current.price > 0)  # price = 0 => not published
                        or (<decimal>hp['price'] > 0 and .current.price = 0)
                        or <Currency>hp['price_currency'] != .current.currency
                      ),
                    select if add_revision
                    then (
                      insert HousingRevision {
                        price := <decimal>hp['price'],
                        currency := <Currency>hp['price_currency'],
                      }
                    ) else ({})
                  ),
                }
              )
            ),

          select housing {
            id,
            is_new := (housing not in Housing),
            added_revision := (
              housing in Housing
              and housing.current not in HousingRevision
            ),
            price := housing.current.price,
            currency := housing.current.currency,
          }
        )\
        """,
        housing_posts=housing_posts,
    )


async def upsert_user(
    executor: edgedb.AsyncIOExecutor, *, telegram_id: int, telegram_username: str | None = None
) -> UpsertUserResult | None:
    return await executor.query_single(
        """\
        with
          telegram_id := <int64>$telegram_id,
          telegram_username := <optional str>$telegram_username,

          user := (
            insert User {
              telegram_id := telegram_id,
              telegram_username := telegram_username,
            }
            unless conflict on .telegram_id
            else (
              update User set {
                telegram_username := telegram_username
              }
            )
          )

        select user {
          is_new := (user not in User),
          id,
          tier,
          telegram_id,
          telegram_username,
          searches: {
            id,
            created_at,
            provider,
            url,
          } order by .created_at asc,
        }\
        """,
        telegram_id=telegram_id,
        telegram_username=telegram_username,
    )


async def upsert_watches_for_search(
    executor: edgedb.AsyncIOExecutor,
    *,
    housing_search_id: uuid.UUID,
    housing_ids: list[uuid.UUID],
    refreshed_at: datetime.datetime,
    as_notified: bool | None = None,
) -> list[UpdateNotifiedHousingWatchesResult]:
    return await executor.query(
        """\
        # Inserts or updates HousingWatches for new/updated Housing, HousingRevision
        #
        # Param `as_notified`: Whether to mark the new/updated HW as already notified

        with
          housing_search_id := <uuid>$housing_search_id,
          housing_ids := <array<uuid>>$housing_ids,
          refreshed_at := <datetime>$refreshed_at,
          as_notified := <optional bool>$as_notified ?? False,

          housing_search := assert_exists((
            update HousingSearch
            filter .id = housing_search_id
            set {
              last_search_at := refreshed_at,
            }
          )),

        for housing_id in array_unpack(housing_ids) union (
          with
            housing := assert_exists((
              select Housing
              filter .id = housing_id
            )),
            # Existing HouseWatch for this Housing, either from the same or from a different HousingSearch
            existing_hw := (
              select HousingWatch
              filter .user = housing_search.user
                and .housing = housing
            ),

          select if exists existing_hw then (
            update existing_hw
            set {
              housing_revision := (select if as_notified then housing.current else .housing_revision),
              notified_at := (select if as_notified then datetime_current() else .notified_at),
            }
          ) else (
            insert HousingWatch {
              search := housing_search,
              housing_revision := housing.current,
              notified_at := (select if as_notified then datetime_current() else <datetime>{}),
            }
          )
        )\
        """,
        housing_search_id=housing_search_id,
        housing_ids=housing_ids,
        refreshed_at=refreshed_at,
        as_notified=as_notified,
    )
